# SOFTWARE ENGINEERING

### Software

Software is collection of programs instruction that provide desired functionality.

### Software Engineering

Software Engineering is the process of designing, developing, testing, and maintaining software in a systematic and structured apporoch to meet the user requirements.Software engineering is the application of scientific principles to the design and creation of software.The field uses a systematic approach to collect and analyze business requirements in order to design, build, and test software applications to satisfy those business requirements.

The inefficiencies in the software development process made it difficult to meet the rapidly increasing demand for computing resources and complex software.This led to what is known as the “Software Crisis” which began in the mid-1960s and
lasted until the mid-1980s.During this period, software development often ran over budget, behind schedule, and consisted of unmanageable, buggy code.**The solution to the “Software Crisis” involved transforming unorganized coding efforts into an established engineering discipline.**

#### DIffrenece between Software Engineer & Developer.

Software engineers are also developers, but the term “software developer” is usually
deemed narrower in scope than that of a software engineer.A software engineer’s knowledge is usually broader.Software engineers take a systematic, big picture approach in their thinking to software.development whereas developers may have more creative approaches.Both software engineers and software developers have specialized knowledge, but software engineers use that knowledge to build entire systems whereas software developers use their knowledge to write code to implement specific functionality within a system.Software engineers are often employed on larger scale projects and they are focused on the broad structure rather than solving an immediate problem.Software engineers are tasked with designing, building, and maintaining software systems.

**I think really has to do with, I consider it a creative process.And it's fundamentally is the practice of designing, envisioning implementing, and then supporting and maintaining software through the full lifecycle of it. So not just writing code, but, you know, thinking about the software you're building before you even written a line of code, the  journey from idea inception to, to actual implementation and launching upset software and then maintaining it, improving it, supporting it, and potentially evolving into something else. So it's very much a sort of creative and full, full lifecycle end to end engineering process.**

#### Aim of Software Engineering
The principal aim of software engineering is to develop high-quality software that is:

- Reliable: Performs the intended functions correctly and consistently.
- Efficient: Optimized for performance and resource usage.
- Maintainable: Easy to modify, extend, and debug.
- Scalable: Can handle growing demands without significant redesign.
- Cost-Effective: Developed and maintained within reasonable budgets.
- Delivered on Time: Meets deadlines without sacrificing quality.
- Satisfying User Requirements: Aligns with the needs and expectations of users and stakeholders.

#### Why is Software Engineering required
- To manage Large software
- For more Scalability
- Cost Management
- To manage the dynamic nature of software
- For better quality Management


#### Objectives of Software Engineering

**Maintainability**: It should be feasible for the software to evolve to meet changing requirements.

**Efficiency**: The software should not make wasteful use of computing devices such as memory, processor cycles, etc.

**Correctness**: A software product is correct if the different requirements specified in the SRS Document have been correctly implemented.

**Reusability**: A software product has good reusability if the different modules of the product can easily be reused to develop new products.

**Testability**: Here software facilitates both the establishment of test criteria and the evaluation of the software concerning those criteria.

**Reliability**: It is an attribute of software quality. Software has ability to perform consistently and accurately in different condition and scenarios . 

**Portability**: In this case, the software can be transferred from one computer system or environment to another.

**Adaptability**: In this case, the software allows differing system constraints and the user needs to be satisfied by making changes to the software.

**Interoperability**: Capability of 2 or more functional units to process data cooperatively.

**Scalability**: The software can handle an increasing workload and it can easily extend to meet the changing requirements.

## Discipline of software engineering

1. Software Development Life Cycle (SDLC)

    Discusses the stages of software development, including:
      -  Requirements Analysis: Understanding user and stakeholder needs.
      -  Design: Structuring the software’s architecture and components.
      -  Implementation: Writing the actual code.
      -  Testing: Verifying the software’s correctness and reliability.
      -  Deployment: Delivering the software to users.
      -  Maintenance: Updating and fixing the software over time.

2. Software Process Models
    Explores methodologies for organizing development activities, such as 
       -  Waterfall Model
       -  Agile Development
       -  Spiral Model
       -  DevOps

4. Requirements Engineering

    Discusses techniques for gathering, analyzing, and documenting software requirements to ensure they are clear, complete, and consistent.

5. Software Design

    Focuses on creating a blueprint for the software, including:
   
      -  Architectural design (e.g., client-server, microservices).
      -  Component and module design.
      -  User interface design.
      -  Design patterns (e.g., Singleton, Factory, MVC).

7. Coding Practices

    Emphasizes best practices for writing clean, efficient, and maintainable code, such as:
      -  Adhering to coding standards.
      -  Using version control systems (e.g., Git).
      -  Documenting code effectively.

8. Software Testing

    Covers strategies for verifying and validating software, including:
     -   Unit testing, integration testing, system testing, and acceptance testing.
     -   Automated testing and test-driven development (TDD).

9. Software Maintenance

    Discusses managing changes to software after deployment, including:
    -    Bug fixes.
    -    Enhancements to functionality.
    -    Adaptation to new environments.

10. Software Project Management

    Examines how to plan, organize, and oversee software projects, including:
     -   Scheduling and resource allocation.
     -   Risk management.
     -  Cost estimation models (e.g., COCOMO).
     -   Team collaboration tools and practices.

11. Software Quality Assurance (SQA)

    Ensures that software meets defined quality standards through:
     -   Process audits.
     -   Code reviews.
     -   Performance and security testing.

## Basic Techniques
- Abstraction

    Definition: Simplifying complex systems by focusing on the essential features while ignoring implementation details.
    Purpose: Helps reduce the cognitive load by breaking down the problem into more understandable components.

- Modularity

    Definition: Dividing the system into smaller, self-contained modules or components that can be developed, tested, and maintained independently.
    Purpose: Makes the system easier to understand, debug, and scale.
  
- Decomposition

    Definition: Breaking down a complex problem into smaller, more manageable sub-problems or tasks.
    Purpose: Simplifies problem-solving and allows for parallel development.
## What is the Need of Software Engineering?

- **Managing Complexity**

    Modern software systems are large and complex, often requiring thousands or even millions of lines of code.
    Without a systematic approach, managing, maintaining, and understanding such systems becomes nearly impossible.
  
- **Quality Assurance**

    Software must be reliable, secure, and free from defects.
    Software engineering practices ensure rigorous testing, debugging, and verification to deliver high-quality products.

- **Scalability and Performance**

    Software systems need to scale to handle increased user demand and adapt to changing requirements.
    Software engineering provides tools and methods to design scalable architectures.
  
- **Cost-Effectiveness**

    Poorly managed software projects can lead to cost overruns and failed deliveries.
    Software engineering practices help optimize resource utilization and ensure projects stay within budget.
  
  - **Maintenance and Evolution**

    Software is not static; it requires regular updates to fix bugs, add features, or adapt to new technologies.
    Software engineering emphasizes maintainable designs, documentation, and modularity for easy updates.

  - **Meeting User Requirements**

    Misunderstanding or incomplete requirements often lead to user dissatisfaction and project failure.
    Software engineering ensures proper requirement analysis, user collaboration, and iterative feedback.

  - **Timely Delivery**

    Delivering software on time is crucial to meet market demands and avoid financial losses.
    Software engineering provides methodologies like Agile and Scrum to ensure efficient development cycles.
