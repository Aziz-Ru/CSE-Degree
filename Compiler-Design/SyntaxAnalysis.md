
## Syntax Analysis
Syntax analysis (parsing) is the second phase of the compilation process, following lexical analysis. Its primary goal is to verify the syntactical correctness of the source code.
It takes the tokens generated by the lexical analyzer and attempts to build a Parse Tree or Abstract Syntax Tree (AST), representing the program’s structure. During this phase, the syntax analyzer checks whether the input string adheres to the grammatical rules of the language using context-free grammar. If the syntax is correct, the analyzer moves forward; otherwise, it reports an error.

But a lexical analyzer cannot check the syntax of a given sentence due to the limitations of the regular expressions. Regular expressions cannot check balancing tokens, such as parenthesis. Therefore, this phase uses context-free grammar (CFG), which is recognized by push-down automata.

### Context Free Grammer
A context free grammers is a set of recursive rules used to generate patterns.  The grammar has four tuples: (V,T,P,S).
- V:finite set of non-terminal
- T:Terminal Symbol
- P:Production Rule
- S:Start Symbol


#### A grammar is said to be the Context-free grammar if every production is in the form of :
```
G -> (V∪T)*, where G ∊ V
```
  - the left-hand side of the G, here in the example, can only be a Variable, it cannot be a terminal.
  - But on the right-hand side here it can be a Variable or Terminal or both combination of Variable and Terminal.
    
#### Limitations of Context-Free Grammar
- Context-Free Grammar can be ambiguous means we can generate multiple parse trees of the same input.
- Context-Free Grammar can be less efficient because of the exponential time complexity.
  
### Push-Down Automata
Pushdown Automata is a finite automata with extra memory called stack which helps Pushdown automata to recognize Context Free Languages. 

### Derivation
A derivation is basically a sequence of production rules, in order to get the input string. 
During parsing, we take two decisions for some sentential form of input:

- Deciding the non-terminal which is to be replaced.
- Deciding the production rule, by which, the non-terminal will be replaced.

There are two types of derivation: 
**Leftmost derivation:** The process of deriving a string by expanding the leftmost non-terminal at each step
**Rightmost derivation:** The process of deriving a string by expanding the rightmost non-terminal at each step

Production Rules:
```
E → E + E
E → E * E
E → id 
```

The left-most derivation is:

```
E → E * E
E → E + E * E
E → id + E * E
E → id + id * E
E → id + id * id
```
Notice that the left-most side non-terminal is always processed first.

The right-most derivation is:

```
E → E + E
E → E + E * E
E → E + E * id
E → E + id * id
E → id + id * id
```

## Parse Tree
A parse tree is a graphical depiction of a derivation. It is convenient to see how strings are derived from the start symbol. 
In a parse tree:
    - All leaf nodes are terminals.
    - All interior nodes are non-terminals.
    - In-order traversal gives original input string.

## Ambiguity

A grammar G is said to be ambiguous if it has more than one parse tree (left or right derivation) for at least one string.

## Left Recursion
A grammar becomes left-recursive if it has any non-terminal ‘A’ whose derivation contains ‘A’ itself as the left-most symbol. A Grammar G (V, T, P, S) is left recursive if it has a production in the form.

A → A α |β.

Top-down parsers start parsing from the Start symbol, which in itself is non-terminal. So, when the parser encounters the same non-terminal in its derivation, it becomes hard for it to judge when to stop parsing the left non-terminal and it goes into an infinite loop.

### Removal of Left Recursion
The production
```
A => Aα | β
```
is converted into following productions
```
A => βA'
A'=> αA' | ε
```

Let The Production Rule:
```
S => Aα | β 
A => Sd
```
after applying the above algorithm, should become
```
S => Aα | β 
A => Aαd | βd
A  => βdA'
A' => αdA' | ε
```

## Left Factoring
If more than one grammar production rules has a common prefix string, then the top-down parser cannot make a choice as to which of the production it should take to parse the string in hand.

If a top-down parser encounters a production like
```
A ⟹ αβ | α𝜸 | …
```

Then it cannot determine which production to follow to parse the string as both productions are starting from the same terminal (or non-terminal). To remove this confusion, we use a technique called left factoring.

Left factoring transforms the grammar to make it useful for top-down parsers. In this technique, we make one production for each common prefixes and the rest of the derivation is added by new productions.

```
A => αA'
A'=> β | 𝜸 | … 
```

## Parsing Algorithms Used in Syntax Analysis

- **LL parsing**: This is a top-down parsing algorithm that starts with the root of the parse tree and constructs the tree by successively expanding non-terminals. LL parsing is known for its simplicity and ease of implementation. 
- **LR parsing**: This is a bottom-up parsing algorithm that starts with the leaves of the parse tree and constructs the tree by successively reducing terminals.LR parsing is more powerful than LL parsing and can handle a larger class of grammars.
- LR(1) parsing: This is a variant of LR parsing that uses lookahead to disambiguate the grammar.
- LALR parsing: This is a variant of LR parsing that uses a reduced set of lookahead symbols to reduce the number of states in the LR parser.

## FIRST AND FOLLOW SET

### FIRST():
First is a function that gives a set of terminal that begin the strings derived from production rule.
Some Examples:
|Production Rule|First set|
|-|-|
|A->aB|{a}|
|A->a\|ε|{a, ε}|
|A->(aB)\| ε|{(, ε}|
|A->Ta,T->*FT'|{*}|
|A->Ta</br>T->*FT'\|ε|{*,a}|

### FOLLOW()
Follow is a function that gives a set of terminal that follows a non-terminal in process of derivation.

**Rules of finding Follow set:**
- If S is the start symbol, FOLLOW (S) ={$}
- If production is of form A → α B β, β ≠ ε.
   - If FIRST (β) does not contain ε then, FOLLOW (B) = {FIRST (β)}
   - If FIRST (β) contains ε (i. e. , β ⇒* ε), then

        FOLLOW (B) = FIRST (β) − {ε} ∪ FOLLOW (A)

∵ when β derives ε, then terminal after A will follow B.

- If production is of form A → αB, then Follow (B) ={FOLLOW (A)}.

Example 1:
|Production Rule|First|Follow|
|---------------|-----|------|
|E->TE'|id,(|$,)|
|E'->+TE'\|ε|+,ε|Follow(E)=>$,)|
|T->FT'|id,(|+,$,)|
|T'->*FT'\|ε|*,ε|+,$,)|
|F->id\|(E)|id,(|*,+,$,)|
This is a LL(1) Parser

## Construction of LL(1) Parsing Table

### Conditions for an LL(1) Grammar
  - No Left Recursion: Avoid recursive definitions like A -> A + b.
  - Unambiguous Grammar: Ensure each string can be derived in only one way.
  - Left Factoring: Make the grammar deterministic, so the parser can proceed without guessing.
### Algorithm to Construct LL(1) Parsing Table

- Calculate First() and Follow() for all non-terminals.
- Make a parser table.
  - null productions are put under the Follow set of that symbol and all the remaining productions lie under the First of that symbol. 

**Every grammar is not feasible for LL(1) Parsing table. It may be possible that one cell may contain more than one production.**

Example 2:
|Production Rule| First|Follow|
|-|-|-|
|S->A/a|a|$|
|A->a|a|$|

Parsing Table:
||a|$|
|-|-|-|
|S|S->A,A->a||
|A|A->a||


Here, we can see that there are two productions in the same cell. Hence, this grammar is not feasible for LL(1) Parser.

Example 3:

|Production Rule|First|Follow|
|-|-|-|
|S->(L)/a|(,a|$,)|
|L->SL'|(,a|)|
|L'->)SL'/ε|),ε|)|

Parsing Table:
||(|)|a|$|
|-|-|-|-|-|
|S|S->(L)||S->a||
|L|L->SL'||S->SL'||
|L'||L'->)SL' </br> L'->ε|||

Here, we can see that there are two productions in the same cell. Hence, this grammar is not feasible for LL(1) Parser.


## LR Parser
In the LR parsing, "L" stands for left-to-right scanning of the input.

"R" stands for constructing a right most derivation in reverse.

"K" is the number of input symbols of the look ahead used to make number of parsing decision.

LR parsing is divided into four parts: LR (0) parsing, SLR parsing, CLR parsing and LALR parsing.


LR parser algorithm :

LR Parsing algorithm is the same for all the parser, but the parsing table is different for each parser.

1. Input Buffer – It contains the given string, and it ends with a $ symbol.
2. Stack – The combination of state symbol and current input symbol is used to refer to the parsing table in order to take the parsing decisions.

Parsing Table : 

Parsing table is divided into two parts- Action table and Go-To table. The action table gives a grammar rule to implement the given current state and current terminal in the input stream. 

1. Shift Action- In shift action the present terminal is removed from the input stream and the state n is pushed onto the stack, and it becomes the new present state.

2. Reduce Action- The number m is written to the output stream.

## Augmented grammar 
If G is a grammar with starting symbol S, then G’ (augmented grammar for G) is a grammar with a new starting symbol S‘ and productions  S’-> .S .

## LR Grammer
```
S–>AA
A–>aA|b
```
STEP 1- Find augmented grammar –
    -  S’–>.S      [0th production]
    -  S–>.AA    [1st production]
    -  A–>.aA    [2nd production]
    -  A–>.b      [3rd production]
    
STEP 2 –  Find LR(0) collection of items

- RULE – if any nonterminal has ‘ . ‘ preceding it, we have to write all its production and add ‘ . ‘ preceding each of its-production.

- RULE –  from each state to the next state, the ‘ . ‘ shifts to one place to the right.

<img src="https://media.geeksforgeeks.org/wp-content/uploads/20210621170906/11.png"/>

- In the figure, I0 consists of augmented grammar.
- Io goes to I1 when  ‘ . ‘ of 0th production is shifted towards the right of S(S’->S.). This state is the accepted state.S is seen by the compiler
- Io goes to I2 when  ‘ . ‘ of 1st production is shifted towards the right (S->A.A) . A is seen by the compiler
- I0 goes to I3 when  ‘ . ‘ of the 2nd production is shifted towards the right (A->a.A) . a is seen by the compiler.
- I0 goes to I4 when  ‘ . ‘ of the 3rd production is shifted towards the right (A->b.) . b is seen by the compiler.
- I2 goes to I5 when  ‘ . ‘ of 1st production is shifted towards the right (S->AA.) . A is seen by the compiler
- I2 goes to I4 when  ‘ . ‘ of 3rd production is shifted towards the right (A->b.) . b is seen by the compiler.
- I2 goes to I3 when  ‘ . ‘ of the 2nd production is shifted towards the right (A->a.A) . a is seen by the compiler.
- 3 goes to I4 when  ‘ . ‘ of the 3rd production is shifted towards the right (A->b.) . b is seen by the compiler.
- I3 goes to I6 when  ‘ . ‘ of 2nd production is shifted towards the right (A->aA.) . A is seen by the compiler


- STEP3: Making Parsing Table from DFA.Parssing Table diffrent from LR(0) SLR,CLR,LALR.
  defining 2 functions: goto[list of non-terminals] and action[list of terminals] in the parsing table.

  - $ is by default a terminal that takes the accepting state.
  - 0,1,2,3,4,5,6 denotes I0,I1,I2,I3,I4,I5,I6
  - I0 gives A in I2, so 2 is added to the A column and 0 rows.
  - I0 gives S in I1, so 1 is added to the S column and 1 row.
  - similarly, 5 is written in  A column and 2nd row, 6 is written in A column and 3 rows.
  - I0 gives an in I3 to .so S3(shift 3) is added to a column and 0 rows.
  - I0 gives b in I4, so S4(shift 4) is added to the b column and 0 rows.
 
  - I4 is reduced state as ‘ . ‘ is at the end. I4 is the 3rd production of grammar. So write r3(reduce 3) in terminals.
  - I5 is reduced state as ‘ . ‘ is at the end. I5 is the 1st production of grammar. So write r1(reduce 1) in terminals.
  - I6 is reduced state as ‘ . ‘ is at the end. I6 is the 2nd production of grammar. So write r2(reduce 2) in terminals.
  

## LR(0)

- Reduce Production rule goes to all the non terminal
- If Grammer has Shift Reduce Conflict that is not LR(0) Grammer.

## SLR(1)

- Uses follow sets of non-terminals as lookahead to resolve conflicts.
- More powerful than LR(0) but less powerful than CLR and LALR.
- Cannot handle all ambiguities in complex grammars.
  
## CLR(1)
- Uses specific lookahead symbols for each item, derived during the construction of the parse table.

The CLR parser stands for canonical LR parser.It is a more powerful LR parser.It makes use of lookahead symbols. This method uses a large set of items called LR(1) items.The main difference between LR(0)  and LR(1) items is that, in LR(1) items, it is possible to carry more information in a state, which will rule out useless reduction states.

### How to add lookahead with the production?

#### CASE 1
```
A->∝.BC, a [0th production.]
```
Suppose this is the 0th production.Now, since ‘ . ‘ precedes B,so we have to write B’s productions as well.
```
B->.D [1st production]
```
Suppose this is B’s production.

The look ahead of this production is given as we look at previous productions ie 0th production. Whatever is after B, we find FIRST(of that value).that is the lookahead of 1st production. that is the lookahead of 1st production.So,here in 0th production, after B, C is there. assume FIRST(C)=d, then 1st production become
```
B->.D, d
```
### CASE 2 
```
A->∝.B, a 
```
Here, we can see there’s nothing after B. So the lookahead of 0th production will be the lookahead of 1st production.

```
B->.D, a
```

### CASE 3 –
Assume a production A->a|b
```
A->a,$ [0th production]
A->b,$ [1st production]
```
Here, the 1st production is a part of the previous production, so the lookahead will be the same as that of its previous production.

## LALR
LALR Parser is lookahead LR parser. It is  the most powerful parser which can handle large classes of grammar. The size of CLR parsing table is quite large as compared to other parsing table. LALR reduces the size of this table.
